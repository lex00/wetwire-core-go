package runner

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"gopkg.in/yaml.v3"
)

// OutputManifest stores outputs captured from domain executions.
// It maps domain names to their resource outputs and can be used
// to pass outputs between dependent domains in cross-domain scenarios.
type OutputManifest struct {
	// Domains maps domain name to domain outputs
	Domains map[string]*DomainOutput `json:"domains" yaml:"domains"`
}

// DomainOutput contains outputs for a single domain.
type DomainOutput struct {
	// Resources maps resource names to their outputs
	Resources map[string]ResourceOutput `json:"resources" yaml:"resources"`

	// Files lists the output files generated by this domain
	Files []string `json:"files,omitempty" yaml:"files,omitempty"`
}

// ResourceOutput contains the output data for a single resource.
type ResourceOutput struct {
	// Type is the resource type (e.g., "aws_s3_bucket", "gitlab_pipeline")
	Type string `json:"type,omitempty" yaml:"type,omitempty"`

	// Outputs is a map of output names to values
	Outputs map[string]interface{} `json:"outputs,omitempty" yaml:"outputs,omitempty"`
}

// NewOutputManifest creates a new empty OutputManifest.
func NewOutputManifest() *OutputManifest {
	return &OutputManifest{
		Domains: make(map[string]*DomainOutput),
	}
}

// AddDomainOutput adds outputs for a domain.
func (m *OutputManifest) AddDomainOutput(domainName string, output *DomainOutput) {
	if m.Domains == nil {
		m.Domains = make(map[string]*DomainOutput)
	}
	m.Domains[domainName] = output
}

// GetDomainOutput retrieves outputs for a domain.
func (m *OutputManifest) GetDomainOutput(domainName string) *DomainOutput {
	if m.Domains == nil {
		return nil
	}
	return m.Domains[domainName]
}

// GetResourceOutput retrieves a specific output value from a resource.
// Returns nil if the domain, resource, or output key is not found.
func (m *OutputManifest) GetResourceOutput(domainName, resourceName, outputKey string) interface{} {
	domainOutput := m.GetDomainOutput(domainName)
	if domainOutput == nil {
		return nil
	}
	resourceOutput, exists := domainOutput.Resources[resourceName]
	if !exists || resourceOutput.Outputs == nil {
		return nil
	}
	return resourceOutput.Outputs[outputKey]
}

// SaveToFile writes the manifest to a JSON file.
func (m *OutputManifest) SaveToFile(path string) error {
	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Marshal with indentation for readability
	data, err := json.MarshalIndent(m, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal manifest: %w", err)
	}

	// Write to file
	if err := os.WriteFile(path, data, 0644); err != nil {
		return fmt.Errorf("failed to write manifest: %w", err)
	}

	return nil
}

// SaveToYAML writes the manifest to a YAML file.
func (m *OutputManifest) SaveToYAML(path string) error {
	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	data, err := yaml.Marshal(m)
	if err != nil {
		return fmt.Errorf("failed to marshal manifest: %w", err)
	}

	if err := os.WriteFile(path, data, 0644); err != nil {
		return fmt.Errorf("failed to write manifest: %w", err)
	}

	return nil
}

// LoadFromFile reads a manifest from a JSON file.
func LoadFromFile(path string) (*OutputManifest, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read manifest: %w", err)
	}

	var manifest OutputManifest
	if err := json.Unmarshal(data, &manifest); err != nil {
		return nil, fmt.Errorf("failed to unmarshal manifest: %w", err)
	}

	return &manifest, nil
}

// LoadFromYAML reads a manifest from a YAML file.
func LoadFromYAML(path string) (*OutputManifest, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read manifest: %w", err)
	}

	var manifest OutputManifest
	if err := yaml.Unmarshal(data, &manifest); err != nil {
		return nil, fmt.Errorf("failed to unmarshal manifest: %w", err)
	}

	return &manifest, nil
}

// OutputExtractor extracts outputs from generated domain files.
type OutputExtractor struct {
	// Patterns maps file extensions to extraction patterns
	Patterns map[string][]*OutputPattern
}

// OutputPattern defines a regex pattern for extracting outputs.
type OutputPattern struct {
	// Name identifies this pattern
	Name string

	// Regex is the pattern to match output declarations
	Regex *regexp.Regexp

	// OutputNameGroup is the index of the capture group for output name
	OutputNameGroup int

	// OutputValueGroup is the index of the capture group for output value
	OutputValueGroup int
}

// NewOutputExtractor creates an extractor with default patterns for common formats.
func NewOutputExtractor() *OutputExtractor {
	return &OutputExtractor{
		Patterns: defaultOutputPatterns(),
	}
}

// defaultOutputPatterns returns patterns for extracting outputs from common file formats.
func defaultOutputPatterns() map[string][]*OutputPattern {
	patterns := make(map[string][]*OutputPattern)

	// CloudFormation/YAML output patterns
	// Matches Output declarations like "  BucketName:" under Outputs section
	yamlOutputPattern := regexp.MustCompile(`(?m)^\s{2}(\w+):\s*$`)

	patterns[".yaml"] = []*OutputPattern{
		{
			Name:            "yaml-output-key",
			Regex:           yamlOutputPattern,
			OutputNameGroup: 1,
		},
	}
	patterns[".yml"] = patterns[".yaml"]

	// JSON output patterns (Terraform, CloudFormation JSON)
	// Matches "output_name": { "value": "..." }
	jsonOutputPattern := regexp.MustCompile(`"(\w+)":\s*\{\s*"value":\s*"([^"]*)"`)
	patterns[".json"] = []*OutputPattern{
		{
			Name:             "json-output",
			Regex:            jsonOutputPattern,
			OutputNameGroup:  1,
			OutputValueGroup: 2,
		},
	}

	// Go wetwire DSL patterns
	// Matches Output("name", ...) or AddOutput("name", ...)
	goOutputPattern := regexp.MustCompile(`(?:Output|AddOutput)\s*\(\s*["'](\w+)["']`)
	patterns[".go"] = []*OutputPattern{
		{
			Name:            "go-output",
			Regex:           goOutputPattern,
			OutputNameGroup: 1,
		},
	}

	return patterns
}

// ExtractFromDir extracts outputs from all matching files in a directory.
func (e *OutputExtractor) ExtractFromDir(workDir, domainName string, outputPatterns []string) (*DomainOutput, error) {
	domainOutput := &DomainOutput{
		Resources: make(map[string]ResourceOutput),
		Files:     []string{},
	}

	// Walk directory and find matching files
	err := filepath.Walk(workDir, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return nil
		}

		relPath, err := filepath.Rel(workDir, path)
		if err != nil {
			return nil
		}

		// Check if file matches output patterns
		if len(outputPatterns) > 0 && !matchesPatterns(relPath, outputPatterns) {
			return nil
		}

		// Track all matched files
		domainOutput.Files = append(domainOutput.Files, relPath)

		// Try to extract outputs based on file extension
		ext := filepath.Ext(path)
		extractedOutputs := e.extractFromFile(path, ext)

		if len(extractedOutputs) > 0 {
			resourceName := inferResourceName(relPath)
			if existing, ok := domainOutput.Resources[resourceName]; ok {
				// Merge outputs
				for k, v := range extractedOutputs {
					existing.Outputs[k] = v
				}
				domainOutput.Resources[resourceName] = existing
			} else {
				domainOutput.Resources[resourceName] = ResourceOutput{
					Type:    domainName + "_" + resourceName,
					Outputs: extractedOutputs,
				}
			}
		}

		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to walk directory: %w", err)
	}

	return domainOutput, nil
}

// extractFromFile extracts outputs from a single file.
func (e *OutputExtractor) extractFromFile(path, ext string) map[string]interface{} {
	outputs := make(map[string]interface{})

	content, err := os.ReadFile(path)
	if err != nil {
		return outputs
	}

	// Try structured parsing first (JSON/YAML)
	if ext == ".json" {
		var data map[string]interface{}
		if err := json.Unmarshal(content, &data); err == nil {
			// Look for Outputs section (CloudFormation) or output blocks (Terraform)
			if outputsSection, ok := data["Outputs"].(map[string]interface{}); ok {
				for name, val := range outputsSection {
					outputs[name] = val
				}
			}
			if outputsSection, ok := data["output"].(map[string]interface{}); ok {
				for name, val := range outputsSection {
					outputs[name] = val
				}
			}
		}
	}

	if ext == ".yaml" || ext == ".yml" {
		var data map[string]interface{}
		if err := yaml.Unmarshal(content, &data); err == nil {
			// Look for Outputs section (CloudFormation)
			if outputsSection, ok := data["Outputs"].(map[string]interface{}); ok {
				for name, val := range outputsSection {
					outputs[name] = val
				}
			}
		}
	}

	// Apply regex patterns for additional extraction
	patterns := e.Patterns[ext]
	for _, pattern := range patterns {
		if pattern.Regex == nil {
			continue
		}

		matches := pattern.Regex.FindAllStringSubmatch(string(content), -1)
		for _, match := range matches {
			if pattern.OutputNameGroup > 0 && pattern.OutputNameGroup < len(match) {
				outputName := match[pattern.OutputNameGroup]
				outputValue := ""
				if pattern.OutputValueGroup > 0 && pattern.OutputValueGroup < len(match) {
					outputValue = match[pattern.OutputValueGroup]
				}
				if outputName != "" && outputs[outputName] == nil {
					if outputValue != "" {
						outputs[outputName] = outputValue
					} else {
						outputs[outputName] = "${" + outputName + "}"
					}
				}
			}
		}
	}

	return outputs
}

// inferResourceName extracts a resource name from a file path.
func inferResourceName(relPath string) string {
	base := filepath.Base(relPath)
	name := strings.TrimSuffix(base, filepath.Ext(base))

	// Map common file names to resource types
	mappings := map[string]string{
		"bucket":     "s3",
		"s3":         "s3",
		"lambda":     "lambda",
		"function":   "lambda",
		"api":        "apigateway",
		"vpc":        "vpc",
		"iam":        "iam",
		"role":       "iam",
		"ec2":        "ec2",
		"instance":   "ec2",
		"rds":        "rds",
		"database":   "rds",
		"pipeline":   "pipeline",
		"workflow":   "workflow",
		"template":   "cloudformation",
		"stack":      "cloudformation",
		"deployment": "kubernetes",
		"service":    "kubernetes",
	}

	nameLower := strings.ToLower(name)
	for pattern, resourceType := range mappings {
		if strings.Contains(nameLower, pattern) {
			return resourceType
		}
	}

	return name
}

// matchesPatterns checks if a path matches any of the given glob patterns.
func matchesPatterns(path string, patterns []string) bool {
	for _, pattern := range patterns {
		matched, err := filepath.Match(pattern, path)
		if err == nil && matched {
			return true
		}
		// Also check against just the filename
		matched, err = filepath.Match(pattern, filepath.Base(path))
		if err == nil && matched {
			return true
		}
	}
	return false
}

// CaptureOutputsFromFiles discovers and captures outputs from generated files.
// This is a helper function that looks for common output patterns in domain files.
func CaptureOutputsFromFiles(workDir string, domainName string, outputPatterns []string) (*DomainOutput, error) {
	extractor := NewOutputExtractor()
	return extractor.ExtractFromDir(workDir, domainName, outputPatterns)
}
